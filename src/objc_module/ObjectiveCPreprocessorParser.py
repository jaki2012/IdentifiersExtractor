# Generated from Z:/IdentifiersExtractor/IdentifiersExtractor/src/objc_module\ObjectiveCPreprocessorParser.g4 by ANTLR 4.7
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u00e0")
        buf.write("a\4\2\t\2\4\3\t\3\4\4\t\4\3\2\3\2\3\2\3\2\3\2\3\2\3\2")
        buf.write("\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3")
        buf.write("\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2")
        buf.write("\3\2\5\2,\n\2\5\2.\n\2\3\3\6\3\61\n\3\r\3\16\3\62\3\4")
        buf.write("\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4?\n\4\3\4\3\4")
        buf.write("\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4L\n\4\5\4N\n\4")
        buf.write("\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\7\4\\")
        buf.write("\n\4\f\4\16\4_\13\4\3\4\2\3\6\5\2\4\6\2\6\3\2\u00bc\u00bd")
        buf.write("\3\2\u00df\u00e0\3\2\u00cf\u00d0\3\2\u00d3\u00d6\2w\2")
        buf.write("-\3\2\2\2\4\60\3\2\2\2\6M\3\2\2\2\b\t\7\u00b8\2\2\t\n")
        buf.write("\t\2\2\2\n.\5\4\3\2\13\f\7\u00b8\2\2\f\r\7\u00c1\2\2\r")
        buf.write(".\5\6\4\2\16\17\7\u00b8\2\2\17\20\7\u00c2\2\2\20.\5\6")
        buf.write("\4\2\21\22\7\u00b8\2\2\22.\7\u00c3\2\2\23\24\7\u00b8\2")
        buf.write("\2\24.\7\u00c7\2\2\25\26\7\u00b8\2\2\26\27\7\u00c5\2\2")
        buf.write("\27.\7\u00d8\2\2\30\31\7\u00b8\2\2\31\32\7\u00c6\2\2\32")
        buf.write(".\7\u00d8\2\2\33\34\7\u00b8\2\2\34\35\7\u00c4\2\2\35.")
        buf.write("\7\u00d8\2\2\36\37\7\u00b8\2\2\37 \7\u00be\2\2 .\5\4\3")
        buf.write("\2!\"\7\u00b8\2\2\"#\7\u00ca\2\2#.\5\4\3\2$%\7\u00b8\2")
        buf.write("\2%&\7\u00cb\2\2&.\5\4\3\2\'(\7\u00b8\2\2()\7\u00bf\2")
        buf.write("\2)+\7\u00d8\2\2*,\5\4\3\2+*\3\2\2\2+,\3\2\2\2,.\3\2\2")
        buf.write("\2-\b\3\2\2\2-\13\3\2\2\2-\16\3\2\2\2-\21\3\2\2\2-\23")
        buf.write("\3\2\2\2-\25\3\2\2\2-\30\3\2\2\2-\33\3\2\2\2-\36\3\2\2")
        buf.write("\2-!\3\2\2\2-$\3\2\2\2-\'\3\2\2\2.\3\3\2\2\2/\61\t\3\2")
        buf.write("\2\60/\3\2\2\2\61\62\3\2\2\2\62\60\3\2\2\2\62\63\3\2\2")
        buf.write("\2\63\5\3\2\2\2\64\65\b\4\1\2\65N\7\u00c8\2\2\66N\7\u00c9")
        buf.write("\2\2\67N\7\u00d9\2\28N\7\u00d7\2\29>\7\u00d8\2\2:;\7\u00cd")
        buf.write("\2\2;<\5\6\4\2<=\7\u00ce\2\2=?\3\2\2\2>:\3\2\2\2>?\3\2")
        buf.write("\2\2?N\3\2\2\2@A\7\u00cd\2\2AB\5\6\4\2BC\7\u00ce\2\2C")
        buf.write("N\3\2\2\2DE\7\u00cc\2\2EN\5\6\4\bFK\7\u00c0\2\2GL\7\u00d8")
        buf.write("\2\2HI\7\u00cd\2\2IJ\7\u00d8\2\2JL\7\u00ce\2\2KG\3\2\2")
        buf.write("\2KH\3\2\2\2LN\3\2\2\2M\64\3\2\2\2M\66\3\2\2\2M\67\3\2")
        buf.write("\2\2M8\3\2\2\2M9\3\2\2\2M@\3\2\2\2MD\3\2\2\2MF\3\2\2\2")
        buf.write("N]\3\2\2\2OP\f\7\2\2PQ\t\4\2\2Q\\\5\6\4\bRS\f\6\2\2ST")
        buf.write("\7\u00d1\2\2T\\\5\6\4\7UV\f\5\2\2VW\7\u00d2\2\2W\\\5\6")
        buf.write("\4\6XY\f\4\2\2YZ\t\5\2\2Z\\\5\6\4\5[O\3\2\2\2[R\3\2\2")
        buf.write("\2[U\3\2\2\2[X\3\2\2\2\\_\3\2\2\2][\3\2\2\2]^\3\2\2\2")
        buf.write("^\7\3\2\2\2_]\3\2\2\2\n+-\62>KM[]")
        return buf.getvalue()


class ObjectiveCPreprocessorParser ( Parser ):

    grammarFileName = "ObjectiveCPreprocessorParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'auto'", "'break'", "'case'", "'char'", 
                     "'const'", "'continue'", "'default'", "'do'", "'double'", 
                     "<INVALID>", "'enum'", "'extern'", "'float'", "'for'", 
                     "'goto'", "<INVALID>", "'inline'", "'int'", "'long'", 
                     "'register'", "'restrict'", "'return'", "'short'", 
                     "'signed'", "'sizeof'", "'static'", "'struct'", "'switch'", 
                     "'typedef'", "'union'", "'unsigned'", "'void'", "'volatile'", 
                     "'while'", "'_Bool'", "'_Complex'", "'_Imaginery'", 
                     "'true'", "'false'", "'BOOL'", "'Class'", "'bycopy'", 
                     "'byref'", "'id'", "'IMP'", "'in'", "'inout'", "'nil'", 
                     "'NO'", "'NULL'", "'oneway'", "'out'", "'Protocol'", 
                     "'SEL'", "'self'", "'super'", "'YES'", "'@autoreleasepool'", 
                     "'@catch'", "'@class'", "'@dynamic'", "'@encode'", 
                     "'@end'", "'@finally'", "'@implementation'", "'@interface'", 
                     "'@import'", "'@package'", "'@protocol'", "'@optional'", 
                     "'@private'", "'@property'", "'@protected'", "'@public'", 
                     "'@required'", "'@selector'", "'@synchronized'", "'@synthesize'", 
                     "'@throw'", "'@try'", "'atomic'", "'nonatomic'", "'retain'", 
                     "'__attribute__'", "'__autoreleasing'", "'__block'", 
                     "'__bridge'", "'__bridge_retained'", "'__bridge_transfer'", 
                     "'__covariant'", "'__contravariant'", "'__deprecated'", 
                     "'__kindof'", "'__strong'", "<INVALID>", "'__unsafe_unretained'", 
                     "'__unused'", "'__weak'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'null_resettable'", "'NS_INLINE'", "'NS_ENUM'", 
                     "'NS_OPTIONS'", "'assign'", "'copy'", "'getter'", "'setter'", 
                     "'strong'", "'readonly'", "'readwrite'", "'weak'", 
                     "'unsafe_unretained'", "'IBOutlet'", "'IBOutletCollection'", 
                     "'IBInspectable'", "'IB_DESIGNABLE'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'__TVOS_PROHIBITED'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'{'", "'}'", "'['", "']'", "';'", "','", "'.'", "'->'", 
                     "'@'", "'='", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'~'", "'?'", "':'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'++'", "'--'", 
                     "'+'", "'-'", "'*'", "'/'", "'&'", "'|'", "'^'", "'%'", 
                     "'+='", "'-='", "'*='", "'/='", "'&='", "'|='", "'^='", 
                     "'%='", "'<<='", "'>>='", "'...'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'\\'", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'defined'", "<INVALID>", "'elif'", "<INVALID>", "'undef'", 
                     "'ifdef'", "'ifndef'", "'endif'" ]

    symbolicNames = [ "<INVALID>", "AUTO", "BREAK", "CASE", "CHAR", "CONST", 
                      "CONTINUE", "DEFAULT", "DO", "DOUBLE", "ELSE", "ENUM", 
                      "EXTERN", "FLOAT", "FOR", "GOTO", "IF", "INLINE", 
                      "INT", "LONG", "REGISTER", "RESTRICT", "RETURN", "SHORT", 
                      "SIGNED", "SIZEOF", "STATIC", "STRUCT", "SWITCH", 
                      "TYPEDEF", "UNION", "UNSIGNED", "VOID", "VOLATILE", 
                      "WHILE", "BOOL_", "COMPLEX", "IMAGINERY", "TRUE", 
                      "FALSE", "BOOL", "Class", "BYCOPY", "BYREF", "ID", 
                      "IMP", "IN", "INOUT", "NIL", "NO", "NULL", "ONEWAY", 
                      "OUT", "PROTOCOL_", "SEL", "SELF", "SUPER", "YES", 
                      "AUTORELEASEPOOL", "CATCH", "CLASS", "DYNAMIC", "ENCODE", 
                      "END", "FINALLY", "IMPLEMENTATION", "INTERFACE", "IMPORT", 
                      "PACKAGE", "PROTOCOL", "OPTIONAL", "PRIVATE", "PROPERTY", 
                      "PROTECTED", "PUBLIC", "REQUIRED", "SELECTOR", "SYNCHRONIZED", 
                      "SYNTHESIZE", "THROW", "TRY", "ATOMIC", "NONATOMIC", 
                      "RETAIN", "ATTRIBUTE", "AUTORELEASING_QUALIFIER", 
                      "BLOCK", "BRIDGE", "BRIDGE_RETAINED", "BRIDGE_TRANSFER", 
                      "COVARIANT", "CONTRAVARIANT", "DEPRECATED", "KINDOF", 
                      "STRONG_QUALIFIER", "TYPEOF", "UNSAFE_UNRETAINED_QUALIFIER", 
                      "UNUSED", "WEAK_QUALIFIER", "NULL_UNSPECIFIED", "NULLABLE", 
                      "NONNULL", "NULL_RESETTABLE", "NS_INLINE", "NS_ENUM", 
                      "NS_OPTIONS", "ASSIGN", "COPY", "GETTER", "SETTER", 
                      "STRONG", "READONLY", "READWRITE", "WEAK", "UNSAFE_UNRETAINED", 
                      "IB_OUTLET", "IB_OUTLET_COLLECTION", "IB_INSPECTABLE", 
                      "IB_DESIGNABLE", "NS_ASSUME_NONNULL_BEGIN", "NS_ASSUME_NONNULL_END", 
                      "EXTERN_SUFFIX", "IOS_SUFFIX", "MAC_SUFFIX", "TVOS_PROHIBITED", 
                      "IDENTIFIER", "LP", "RP", "LBRACE", "RBRACE", "LBRACK", 
                      "RBRACK", "SEMI", "COMMA", "DOT", "STRUCTACCESS", 
                      "AT", "ASSIGNMENT", "GT", "LT", "BANG", "TILDE", "QUESTION", 
                      "COLON", "EQUAL", "LE", "GE", "NOTEQUAL", "AND", "OR", 
                      "INC", "DEC", "ADD", "SUB", "MUL", "DIV", "BITAND", 
                      "BITOR", "BITXOR", "MOD", "ADD_ASSIGN", "SUB_ASSIGN", 
                      "MUL_ASSIGN", "DIV_ASSIGN", "AND_ASSIGN", "OR_ASSIGN", 
                      "XOR_ASSIGN", "MOD_ASSIGN", "LSHIFT_ASSIGN", "RSHIFT_ASSIGN", 
                      "ELIPSIS", "CHARACTER_LITERAL", "STRING_START", "HEX_LITERAL", 
                      "OCTAL_LITERAL", "BINARY_LITERAL", "DECIMAL_LITERAL", 
                      "FLOATING_POINT_LITERAL", "WS", "MULTI_COMMENT", "SINGLE_COMMENT", 
                      "BACKSLASH", "SHARP", "STRING_NEWLINE", "STRING_END", 
                      "STRING_VALUE", "DIRECTIVE_IMPORT", "DIRECTIVE_INCLUDE", 
                      "DIRECTIVE_PRAGMA", "DIRECTIVE_DEFINE", "DIRECTIVE_DEFINED", 
                      "DIRECTIVE_IF", "DIRECTIVE_ELIF", "DIRECTIVE_ELSE", 
                      "DIRECTIVE_UNDEF", "DIRECTIVE_IFDEF", "DIRECTIVE_IFNDEF", 
                      "DIRECTIVE_ENDIF", "DIRECTIVE_TRUE", "DIRECTIVE_FALSE", 
                      "DIRECTIVE_ERROR", "DIRECTIVE_WARNING", "DIRECTIVE_BANG", 
                      "DIRECTIVE_LP", "DIRECTIVE_RP", "DIRECTIVE_EQUAL", 
                      "DIRECTIVE_NOTEQUAL", "DIRECTIVE_AND", "DIRECTIVE_OR", 
                      "DIRECTIVE_LT", "DIRECTIVE_GT", "DIRECTIVE_LE", "DIRECTIVE_GE", 
                      "DIRECTIVE_STRING", "DIRECTIVE_ID", "DIRECTIVE_DECIMAL_LITERAL", 
                      "DIRECTIVE_FLOAT", "DIRECTIVE_NEWLINE", "DIRECTIVE_MULTI_COMMENT", 
                      "DIRECTIVE_SINGLE_COMMENT", "DIRECTIVE_BACKSLASH_NEWLINE", 
                      "DIRECTIVE_TEXT_NEWLINE", "DIRECTIVE_TEXT" ]

    RULE_directive = 0
    RULE_directiveText = 1
    RULE_preprocessorExpression = 2

    ruleNames =  [ "directive", "directiveText", "preprocessorExpression" ]

    EOF = Token.EOF
    AUTO=1
    BREAK=2
    CASE=3
    CHAR=4
    CONST=5
    CONTINUE=6
    DEFAULT=7
    DO=8
    DOUBLE=9
    ELSE=10
    ENUM=11
    EXTERN=12
    FLOAT=13
    FOR=14
    GOTO=15
    IF=16
    INLINE=17
    INT=18
    LONG=19
    REGISTER=20
    RESTRICT=21
    RETURN=22
    SHORT=23
    SIGNED=24
    SIZEOF=25
    STATIC=26
    STRUCT=27
    SWITCH=28
    TYPEDEF=29
    UNION=30
    UNSIGNED=31
    VOID=32
    VOLATILE=33
    WHILE=34
    BOOL_=35
    COMPLEX=36
    IMAGINERY=37
    TRUE=38
    FALSE=39
    BOOL=40
    Class=41
    BYCOPY=42
    BYREF=43
    ID=44
    IMP=45
    IN=46
    INOUT=47
    NIL=48
    NO=49
    NULL=50
    ONEWAY=51
    OUT=52
    PROTOCOL_=53
    SEL=54
    SELF=55
    SUPER=56
    YES=57
    AUTORELEASEPOOL=58
    CATCH=59
    CLASS=60
    DYNAMIC=61
    ENCODE=62
    END=63
    FINALLY=64
    IMPLEMENTATION=65
    INTERFACE=66
    IMPORT=67
    PACKAGE=68
    PROTOCOL=69
    OPTIONAL=70
    PRIVATE=71
    PROPERTY=72
    PROTECTED=73
    PUBLIC=74
    REQUIRED=75
    SELECTOR=76
    SYNCHRONIZED=77
    SYNTHESIZE=78
    THROW=79
    TRY=80
    ATOMIC=81
    NONATOMIC=82
    RETAIN=83
    ATTRIBUTE=84
    AUTORELEASING_QUALIFIER=85
    BLOCK=86
    BRIDGE=87
    BRIDGE_RETAINED=88
    BRIDGE_TRANSFER=89
    COVARIANT=90
    CONTRAVARIANT=91
    DEPRECATED=92
    KINDOF=93
    STRONG_QUALIFIER=94
    TYPEOF=95
    UNSAFE_UNRETAINED_QUALIFIER=96
    UNUSED=97
    WEAK_QUALIFIER=98
    NULL_UNSPECIFIED=99
    NULLABLE=100
    NONNULL=101
    NULL_RESETTABLE=102
    NS_INLINE=103
    NS_ENUM=104
    NS_OPTIONS=105
    ASSIGN=106
    COPY=107
    GETTER=108
    SETTER=109
    STRONG=110
    READONLY=111
    READWRITE=112
    WEAK=113
    UNSAFE_UNRETAINED=114
    IB_OUTLET=115
    IB_OUTLET_COLLECTION=116
    IB_INSPECTABLE=117
    IB_DESIGNABLE=118
    NS_ASSUME_NONNULL_BEGIN=119
    NS_ASSUME_NONNULL_END=120
    EXTERN_SUFFIX=121
    IOS_SUFFIX=122
    MAC_SUFFIX=123
    TVOS_PROHIBITED=124
    IDENTIFIER=125
    LP=126
    RP=127
    LBRACE=128
    RBRACE=129
    LBRACK=130
    RBRACK=131
    SEMI=132
    COMMA=133
    DOT=134
    STRUCTACCESS=135
    AT=136
    ASSIGNMENT=137
    GT=138
    LT=139
    BANG=140
    TILDE=141
    QUESTION=142
    COLON=143
    EQUAL=144
    LE=145
    GE=146
    NOTEQUAL=147
    AND=148
    OR=149
    INC=150
    DEC=151
    ADD=152
    SUB=153
    MUL=154
    DIV=155
    BITAND=156
    BITOR=157
    BITXOR=158
    MOD=159
    ADD_ASSIGN=160
    SUB_ASSIGN=161
    MUL_ASSIGN=162
    DIV_ASSIGN=163
    AND_ASSIGN=164
    OR_ASSIGN=165
    XOR_ASSIGN=166
    MOD_ASSIGN=167
    LSHIFT_ASSIGN=168
    RSHIFT_ASSIGN=169
    ELIPSIS=170
    CHARACTER_LITERAL=171
    STRING_START=172
    HEX_LITERAL=173
    OCTAL_LITERAL=174
    BINARY_LITERAL=175
    DECIMAL_LITERAL=176
    FLOATING_POINT_LITERAL=177
    WS=178
    MULTI_COMMENT=179
    SINGLE_COMMENT=180
    BACKSLASH=181
    SHARP=182
    STRING_NEWLINE=183
    STRING_END=184
    STRING_VALUE=185
    DIRECTIVE_IMPORT=186
    DIRECTIVE_INCLUDE=187
    DIRECTIVE_PRAGMA=188
    DIRECTIVE_DEFINE=189
    DIRECTIVE_DEFINED=190
    DIRECTIVE_IF=191
    DIRECTIVE_ELIF=192
    DIRECTIVE_ELSE=193
    DIRECTIVE_UNDEF=194
    DIRECTIVE_IFDEF=195
    DIRECTIVE_IFNDEF=196
    DIRECTIVE_ENDIF=197
    DIRECTIVE_TRUE=198
    DIRECTIVE_FALSE=199
    DIRECTIVE_ERROR=200
    DIRECTIVE_WARNING=201
    DIRECTIVE_BANG=202
    DIRECTIVE_LP=203
    DIRECTIVE_RP=204
    DIRECTIVE_EQUAL=205
    DIRECTIVE_NOTEQUAL=206
    DIRECTIVE_AND=207
    DIRECTIVE_OR=208
    DIRECTIVE_LT=209
    DIRECTIVE_GT=210
    DIRECTIVE_LE=211
    DIRECTIVE_GE=212
    DIRECTIVE_STRING=213
    DIRECTIVE_ID=214
    DIRECTIVE_DECIMAL_LITERAL=215
    DIRECTIVE_FLOAT=216
    DIRECTIVE_NEWLINE=217
    DIRECTIVE_MULTI_COMMENT=218
    DIRECTIVE_SINGLE_COMMENT=219
    DIRECTIVE_BACKSLASH_NEWLINE=220
    DIRECTIVE_TEXT_NEWLINE=221
    DIRECTIVE_TEXT=222

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class DirectiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ObjectiveCPreprocessorParser.RULE_directive

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class PreprocessorDefContext(DirectiveContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ObjectiveCPreprocessorParser.DirectiveContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SHARP(self):
            return self.getToken(ObjectiveCPreprocessorParser.SHARP, 0)
        def DIRECTIVE_IFDEF(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_IFDEF, 0)
        def DIRECTIVE_ID(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_ID, 0)
        def DIRECTIVE_IFNDEF(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_IFNDEF, 0)
        def DIRECTIVE_UNDEF(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_UNDEF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreprocessorDef" ):
                listener.enterPreprocessorDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreprocessorDef" ):
                listener.exitPreprocessorDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreprocessorDef" ):
                return visitor.visitPreprocessorDef(self)
            else:
                return visitor.visitChildren(self)


    class PreprocessorErrorContext(DirectiveContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ObjectiveCPreprocessorParser.DirectiveContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SHARP(self):
            return self.getToken(ObjectiveCPreprocessorParser.SHARP, 0)
        def DIRECTIVE_ERROR(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_ERROR, 0)
        def directiveText(self):
            return self.getTypedRuleContext(ObjectiveCPreprocessorParser.DirectiveTextContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreprocessorError" ):
                listener.enterPreprocessorError(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreprocessorError" ):
                listener.exitPreprocessorError(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreprocessorError" ):
                return visitor.visitPreprocessorError(self)
            else:
                return visitor.visitChildren(self)


    class PreprocessorConditionalContext(DirectiveContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ObjectiveCPreprocessorParser.DirectiveContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SHARP(self):
            return self.getToken(ObjectiveCPreprocessorParser.SHARP, 0)
        def DIRECTIVE_IF(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_IF, 0)
        def preprocessorExpression(self):
            return self.getTypedRuleContext(ObjectiveCPreprocessorParser.PreprocessorExpressionContext,0)

        def DIRECTIVE_ELIF(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_ELIF, 0)
        def DIRECTIVE_ELSE(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_ELSE, 0)
        def DIRECTIVE_ENDIF(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_ENDIF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreprocessorConditional" ):
                listener.enterPreprocessorConditional(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreprocessorConditional" ):
                listener.exitPreprocessorConditional(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreprocessorConditional" ):
                return visitor.visitPreprocessorConditional(self)
            else:
                return visitor.visitChildren(self)


    class PreprocessorImportContext(DirectiveContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ObjectiveCPreprocessorParser.DirectiveContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SHARP(self):
            return self.getToken(ObjectiveCPreprocessorParser.SHARP, 0)
        def directiveText(self):
            return self.getTypedRuleContext(ObjectiveCPreprocessorParser.DirectiveTextContext,0)

        def DIRECTIVE_IMPORT(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_IMPORT, 0)
        def DIRECTIVE_INCLUDE(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_INCLUDE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreprocessorImport" ):
                listener.enterPreprocessorImport(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreprocessorImport" ):
                listener.exitPreprocessorImport(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreprocessorImport" ):
                return visitor.visitPreprocessorImport(self)
            else:
                return visitor.visitChildren(self)


    class PreprocessorPragmaContext(DirectiveContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ObjectiveCPreprocessorParser.DirectiveContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SHARP(self):
            return self.getToken(ObjectiveCPreprocessorParser.SHARP, 0)
        def DIRECTIVE_PRAGMA(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_PRAGMA, 0)
        def directiveText(self):
            return self.getTypedRuleContext(ObjectiveCPreprocessorParser.DirectiveTextContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreprocessorPragma" ):
                listener.enterPreprocessorPragma(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreprocessorPragma" ):
                listener.exitPreprocessorPragma(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreprocessorPragma" ):
                return visitor.visitPreprocessorPragma(self)
            else:
                return visitor.visitChildren(self)


    class PreprocessorDefineContext(DirectiveContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ObjectiveCPreprocessorParser.DirectiveContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SHARP(self):
            return self.getToken(ObjectiveCPreprocessorParser.SHARP, 0)
        def DIRECTIVE_DEFINE(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_DEFINE, 0)
        def DIRECTIVE_ID(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_ID, 0)
        def directiveText(self):
            return self.getTypedRuleContext(ObjectiveCPreprocessorParser.DirectiveTextContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreprocessorDefine" ):
                listener.enterPreprocessorDefine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreprocessorDefine" ):
                listener.exitPreprocessorDefine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreprocessorDefine" ):
                return visitor.visitPreprocessorDefine(self)
            else:
                return visitor.visitChildren(self)


    class PreprocessorWarningContext(DirectiveContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ObjectiveCPreprocessorParser.DirectiveContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SHARP(self):
            return self.getToken(ObjectiveCPreprocessorParser.SHARP, 0)
        def DIRECTIVE_WARNING(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_WARNING, 0)
        def directiveText(self):
            return self.getTypedRuleContext(ObjectiveCPreprocessorParser.DirectiveTextContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreprocessorWarning" ):
                listener.enterPreprocessorWarning(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreprocessorWarning" ):
                listener.exitPreprocessorWarning(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreprocessorWarning" ):
                return visitor.visitPreprocessorWarning(self)
            else:
                return visitor.visitChildren(self)



    def directive(self):

        localctx = ObjectiveCPreprocessorParser.DirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_directive)
        self._la = 0 # Token type
        try:
            self.state = 43
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                localctx = ObjectiveCPreprocessorParser.PreprocessorImportContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 6
                self.match(ObjectiveCPreprocessorParser.SHARP)
                self.state = 7
                _la = self._input.LA(1)
                if not(_la==ObjectiveCPreprocessorParser.DIRECTIVE_IMPORT or _la==ObjectiveCPreprocessorParser.DIRECTIVE_INCLUDE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 8
                self.directiveText()
                pass

            elif la_ == 2:
                localctx = ObjectiveCPreprocessorParser.PreprocessorConditionalContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 9
                self.match(ObjectiveCPreprocessorParser.SHARP)
                self.state = 10
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_IF)
                self.state = 11
                self.preprocessorExpression(0)
                pass

            elif la_ == 3:
                localctx = ObjectiveCPreprocessorParser.PreprocessorConditionalContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 12
                self.match(ObjectiveCPreprocessorParser.SHARP)
                self.state = 13
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_ELIF)
                self.state = 14
                self.preprocessorExpression(0)
                pass

            elif la_ == 4:
                localctx = ObjectiveCPreprocessorParser.PreprocessorConditionalContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 15
                self.match(ObjectiveCPreprocessorParser.SHARP)
                self.state = 16
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_ELSE)
                pass

            elif la_ == 5:
                localctx = ObjectiveCPreprocessorParser.PreprocessorConditionalContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 17
                self.match(ObjectiveCPreprocessorParser.SHARP)
                self.state = 18
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_ENDIF)
                pass

            elif la_ == 6:
                localctx = ObjectiveCPreprocessorParser.PreprocessorDefContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 19
                self.match(ObjectiveCPreprocessorParser.SHARP)
                self.state = 20
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_IFDEF)
                self.state = 21
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_ID)
                pass

            elif la_ == 7:
                localctx = ObjectiveCPreprocessorParser.PreprocessorDefContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 22
                self.match(ObjectiveCPreprocessorParser.SHARP)
                self.state = 23
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_IFNDEF)
                self.state = 24
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_ID)
                pass

            elif la_ == 8:
                localctx = ObjectiveCPreprocessorParser.PreprocessorDefContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 25
                self.match(ObjectiveCPreprocessorParser.SHARP)
                self.state = 26
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_UNDEF)
                self.state = 27
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_ID)
                pass

            elif la_ == 9:
                localctx = ObjectiveCPreprocessorParser.PreprocessorPragmaContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 28
                self.match(ObjectiveCPreprocessorParser.SHARP)
                self.state = 29
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_PRAGMA)
                self.state = 30
                self.directiveText()
                pass

            elif la_ == 10:
                localctx = ObjectiveCPreprocessorParser.PreprocessorErrorContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 31
                self.match(ObjectiveCPreprocessorParser.SHARP)
                self.state = 32
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_ERROR)
                self.state = 33
                self.directiveText()
                pass

            elif la_ == 11:
                localctx = ObjectiveCPreprocessorParser.PreprocessorWarningContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 34
                self.match(ObjectiveCPreprocessorParser.SHARP)
                self.state = 35
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_WARNING)
                self.state = 36
                self.directiveText()
                pass

            elif la_ == 12:
                localctx = ObjectiveCPreprocessorParser.PreprocessorDefineContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 37
                self.match(ObjectiveCPreprocessorParser.SHARP)
                self.state = 38
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_DEFINE)
                self.state = 39
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_ID)
                self.state = 41
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==ObjectiveCPreprocessorParser.DIRECTIVE_TEXT_NEWLINE or _la==ObjectiveCPreprocessorParser.DIRECTIVE_TEXT:
                    self.state = 40
                    self.directiveText()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DirectiveTextContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIRECTIVE_TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(ObjectiveCPreprocessorParser.DIRECTIVE_TEXT)
            else:
                return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_TEXT, i)

        def DIRECTIVE_TEXT_NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(ObjectiveCPreprocessorParser.DIRECTIVE_TEXT_NEWLINE)
            else:
                return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_TEXT_NEWLINE, i)

        def getRuleIndex(self):
            return ObjectiveCPreprocessorParser.RULE_directiveText

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirectiveText" ):
                listener.enterDirectiveText(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirectiveText" ):
                listener.exitDirectiveText(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirectiveText" ):
                return visitor.visitDirectiveText(self)
            else:
                return visitor.visitChildren(self)




    def directiveText(self):

        localctx = ObjectiveCPreprocessorParser.DirectiveTextContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_directiveText)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 46 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 45
                _la = self._input.LA(1)
                if not(_la==ObjectiveCPreprocessorParser.DIRECTIVE_TEXT_NEWLINE or _la==ObjectiveCPreprocessorParser.DIRECTIVE_TEXT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 48 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==ObjectiveCPreprocessorParser.DIRECTIVE_TEXT_NEWLINE or _la==ObjectiveCPreprocessorParser.DIRECTIVE_TEXT):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PreprocessorExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ObjectiveCPreprocessorParser.RULE_preprocessorExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class PreprocessorParenthesisContext(PreprocessorExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ObjectiveCPreprocessorParser.PreprocessorExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DIRECTIVE_LP(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_LP, 0)
        def preprocessorExpression(self):
            return self.getTypedRuleContext(ObjectiveCPreprocessorParser.PreprocessorExpressionContext,0)

        def DIRECTIVE_RP(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_RP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreprocessorParenthesis" ):
                listener.enterPreprocessorParenthesis(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreprocessorParenthesis" ):
                listener.exitPreprocessorParenthesis(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreprocessorParenthesis" ):
                return visitor.visitPreprocessorParenthesis(self)
            else:
                return visitor.visitChildren(self)


    class PreprocessorNotContext(PreprocessorExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ObjectiveCPreprocessorParser.PreprocessorExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DIRECTIVE_BANG(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_BANG, 0)
        def preprocessorExpression(self):
            return self.getTypedRuleContext(ObjectiveCPreprocessorParser.PreprocessorExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreprocessorNot" ):
                listener.enterPreprocessorNot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreprocessorNot" ):
                listener.exitPreprocessorNot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreprocessorNot" ):
                return visitor.visitPreprocessorNot(self)
            else:
                return visitor.visitChildren(self)


    class PreprocessorBinaryContext(PreprocessorExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ObjectiveCPreprocessorParser.PreprocessorExpressionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def preprocessorExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ObjectiveCPreprocessorParser.PreprocessorExpressionContext)
            else:
                return self.getTypedRuleContext(ObjectiveCPreprocessorParser.PreprocessorExpressionContext,i)

        def DIRECTIVE_EQUAL(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_EQUAL, 0)
        def DIRECTIVE_NOTEQUAL(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_NOTEQUAL, 0)
        def DIRECTIVE_AND(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_AND, 0)
        def DIRECTIVE_OR(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_OR, 0)
        def DIRECTIVE_LT(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_LT, 0)
        def DIRECTIVE_GT(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_GT, 0)
        def DIRECTIVE_LE(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_LE, 0)
        def DIRECTIVE_GE(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_GE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreprocessorBinary" ):
                listener.enterPreprocessorBinary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreprocessorBinary" ):
                listener.exitPreprocessorBinary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreprocessorBinary" ):
                return visitor.visitPreprocessorBinary(self)
            else:
                return visitor.visitChildren(self)


    class PreprocessorConstantContext(PreprocessorExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ObjectiveCPreprocessorParser.PreprocessorExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DIRECTIVE_TRUE(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_TRUE, 0)
        def DIRECTIVE_FALSE(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_FALSE, 0)
        def DIRECTIVE_DECIMAL_LITERAL(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_DECIMAL_LITERAL, 0)
        def DIRECTIVE_STRING(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_STRING, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreprocessorConstant" ):
                listener.enterPreprocessorConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreprocessorConstant" ):
                listener.exitPreprocessorConstant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreprocessorConstant" ):
                return visitor.visitPreprocessorConstant(self)
            else:
                return visitor.visitChildren(self)


    class PreprocessorConditionalSymbolContext(PreprocessorExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ObjectiveCPreprocessorParser.PreprocessorExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DIRECTIVE_ID(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_ID, 0)
        def DIRECTIVE_LP(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_LP, 0)
        def preprocessorExpression(self):
            return self.getTypedRuleContext(ObjectiveCPreprocessorParser.PreprocessorExpressionContext,0)

        def DIRECTIVE_RP(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_RP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreprocessorConditionalSymbol" ):
                listener.enterPreprocessorConditionalSymbol(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreprocessorConditionalSymbol" ):
                listener.exitPreprocessorConditionalSymbol(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreprocessorConditionalSymbol" ):
                return visitor.visitPreprocessorConditionalSymbol(self)
            else:
                return visitor.visitChildren(self)


    class PreprocessorDefinedContext(PreprocessorExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ObjectiveCPreprocessorParser.PreprocessorExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DIRECTIVE_DEFINED(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_DEFINED, 0)
        def DIRECTIVE_ID(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_ID, 0)
        def DIRECTIVE_LP(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_LP, 0)
        def DIRECTIVE_RP(self):
            return self.getToken(ObjectiveCPreprocessorParser.DIRECTIVE_RP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreprocessorDefined" ):
                listener.enterPreprocessorDefined(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreprocessorDefined" ):
                listener.exitPreprocessorDefined(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreprocessorDefined" ):
                return visitor.visitPreprocessorDefined(self)
            else:
                return visitor.visitChildren(self)



    def preprocessorExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ObjectiveCPreprocessorParser.PreprocessorExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 4
        self.enterRecursionRule(localctx, 4, self.RULE_preprocessorExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 75
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ObjectiveCPreprocessorParser.DIRECTIVE_TRUE]:
                localctx = ObjectiveCPreprocessorParser.PreprocessorConstantContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 51
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_TRUE)
                pass
            elif token in [ObjectiveCPreprocessorParser.DIRECTIVE_FALSE]:
                localctx = ObjectiveCPreprocessorParser.PreprocessorConstantContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 52
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_FALSE)
                pass
            elif token in [ObjectiveCPreprocessorParser.DIRECTIVE_DECIMAL_LITERAL]:
                localctx = ObjectiveCPreprocessorParser.PreprocessorConstantContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 53
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_DECIMAL_LITERAL)
                pass
            elif token in [ObjectiveCPreprocessorParser.DIRECTIVE_STRING]:
                localctx = ObjectiveCPreprocessorParser.PreprocessorConstantContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 54
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_STRING)
                pass
            elif token in [ObjectiveCPreprocessorParser.DIRECTIVE_ID]:
                localctx = ObjectiveCPreprocessorParser.PreprocessorConditionalSymbolContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 55
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_ID)
                self.state = 60
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
                if la_ == 1:
                    self.state = 56
                    self.match(ObjectiveCPreprocessorParser.DIRECTIVE_LP)
                    self.state = 57
                    self.preprocessorExpression(0)
                    self.state = 58
                    self.match(ObjectiveCPreprocessorParser.DIRECTIVE_RP)


                pass
            elif token in [ObjectiveCPreprocessorParser.DIRECTIVE_LP]:
                localctx = ObjectiveCPreprocessorParser.PreprocessorParenthesisContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 62
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_LP)
                self.state = 63
                self.preprocessorExpression(0)
                self.state = 64
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_RP)
                pass
            elif token in [ObjectiveCPreprocessorParser.DIRECTIVE_BANG]:
                localctx = ObjectiveCPreprocessorParser.PreprocessorNotContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 66
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_BANG)
                self.state = 67
                self.preprocessorExpression(6)
                pass
            elif token in [ObjectiveCPreprocessorParser.DIRECTIVE_DEFINED]:
                localctx = ObjectiveCPreprocessorParser.PreprocessorDefinedContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 68
                self.match(ObjectiveCPreprocessorParser.DIRECTIVE_DEFINED)
                self.state = 73
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [ObjectiveCPreprocessorParser.DIRECTIVE_ID]:
                    self.state = 69
                    self.match(ObjectiveCPreprocessorParser.DIRECTIVE_ID)
                    pass
                elif token in [ObjectiveCPreprocessorParser.DIRECTIVE_LP]:
                    self.state = 70
                    self.match(ObjectiveCPreprocessorParser.DIRECTIVE_LP)
                    self.state = 71
                    self.match(ObjectiveCPreprocessorParser.DIRECTIVE_ID)
                    self.state = 72
                    self.match(ObjectiveCPreprocessorParser.DIRECTIVE_RP)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 91
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,7,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 89
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
                    if la_ == 1:
                        localctx = ObjectiveCPreprocessorParser.PreprocessorBinaryContext(self, ObjectiveCPreprocessorParser.PreprocessorExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_preprocessorExpression)
                        self.state = 77
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 78
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==ObjectiveCPreprocessorParser.DIRECTIVE_EQUAL or _la==ObjectiveCPreprocessorParser.DIRECTIVE_NOTEQUAL):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 79
                        self.preprocessorExpression(6)
                        pass

                    elif la_ == 2:
                        localctx = ObjectiveCPreprocessorParser.PreprocessorBinaryContext(self, ObjectiveCPreprocessorParser.PreprocessorExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_preprocessorExpression)
                        self.state = 80
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 81
                        localctx.op = self.match(ObjectiveCPreprocessorParser.DIRECTIVE_AND)
                        self.state = 82
                        self.preprocessorExpression(5)
                        pass

                    elif la_ == 3:
                        localctx = ObjectiveCPreprocessorParser.PreprocessorBinaryContext(self, ObjectiveCPreprocessorParser.PreprocessorExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_preprocessorExpression)
                        self.state = 83
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 84
                        localctx.op = self.match(ObjectiveCPreprocessorParser.DIRECTIVE_OR)
                        self.state = 85
                        self.preprocessorExpression(4)
                        pass

                    elif la_ == 4:
                        localctx = ObjectiveCPreprocessorParser.PreprocessorBinaryContext(self, ObjectiveCPreprocessorParser.PreprocessorExpressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_preprocessorExpression)
                        self.state = 86
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 87
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(((((_la - 209)) & ~0x3f) == 0 and ((1 << (_la - 209)) & ((1 << (ObjectiveCPreprocessorParser.DIRECTIVE_LT - 209)) | (1 << (ObjectiveCPreprocessorParser.DIRECTIVE_GT - 209)) | (1 << (ObjectiveCPreprocessorParser.DIRECTIVE_LE - 209)) | (1 << (ObjectiveCPreprocessorParser.DIRECTIVE_GE - 209)))) != 0)):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 88
                        self.preprocessorExpression(3)
                        pass

             
                self.state = 93
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[2] = self.preprocessorExpression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def preprocessorExpression_sempred(self, localctx:PreprocessorExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 2)
         




